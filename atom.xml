<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wanghao Blogs</title>
  <subtitle>但行好事 莫问前程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-11T13:07:24.110Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wanghao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS中的异步问题</title>
    <link href="http://yoursite.com/2017/08/09/%E6%B5%85%E8%B0%88JS%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/08/09/浅谈JS中的异步问题/</id>
    <published>2017-08-09T10:46:33.000Z</published>
    <updated>2017-08-11T13:07:24.110Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=449818934&auto=1&height=32"></iframe>

<p>JS的单线程</p>
<p>Javascript是单线程的，可以说单线程是Javascript语言最本质的特性之一。Javascript引擎在运行js代码的时候，同一个时间只能执行单个任务。</p>
<p>Javascript最初被设计成一种浏览器脚本语言，决策者们仅仅是需要一门轻量的浏览器脚本语言来做一些简单的用户交互及DOM操作。相比多线程，单线程不需要考虑创建线程、销毁线程、线程间通信等等诸如此类的复杂问题。所以，为了避免复杂性，Javascript从诞生伊始就是单线程。</p>
<pre><code>Javascript中的异步原理
</code></pre><p>在C#、Java等语言中，异步操作往往是创建一个线程来执行异步任务，异步任务执行完毕之后再将执行结果通知给主线程。这其中往往会伴随着，多线程、线程池、并发等相关术语。但是在Javascript中不存在这些。<br>如前文所述，Javascript是单线程的，那么Javascript的异步是怎么回事呢？</p>
<p>两组概念<br>我们应该首先明确两组概念。就是同步和异步以及阻塞和非阻塞这两组概念。</p>
<p>首先这是两组不同的概念。同步、异步一般指的是消息的通信机制；而阻塞、非阻塞一般强调的是程序在等待（消息）时的状态。</p>
<p>同步  发出一个功能调用（执行函数）时，在没有得到调用结果之前，该调用就不会返回 </p>
<p>异步  发出一个调用后，不关心结果返回，而是立即返回。结果出来后，将会通过一些额外手段通知调用者    注1</p>
<p>阻塞  在调用结果返回之前，当前线程会被挂起等待。直到得到结果之后函数调用才会返回。</p>
<p>非阻塞 在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。<br>注1：这里所说的额外手段，往往是指异步调用的一些具体实现方式，比如事件监听、轮询等等。<br>可见，同步、异步和阻塞、非阻塞是两组概念，我们不应该混淆他们。同时，这两组概念其实是可以共存，可以混合搭配最多四种模式。</p>
<p>其实Javascript中的异步并非真正意思上的异步，它最多能做到非阻塞的地步。所以Node.js官网在介绍自己时仅仅是说“基于事件驱动”，“非阻塞IO模型”，并没有提到异步的字眼。</p>
<pre><code>JS中的异步
</code></pre><p>在Javascript中，Javascript中异步的应用场景主要有两个，其一是基于浏览器的各种异步IO和事件监听，其二是Javascript代码中的关于定时器（setTimeout、setInterval）的应用。<br>对于异步IO，比如ajax异步请求。当js代码发出一个ajax请求时，浏览器仍然会接着往下执行js代码。我们将处理ajax返回的逻辑绑定在ajax回调函数上，当ajax请求完毕成功返回时会触发回调函数，然后接着执行我们绑定的处理逻辑。</p>
<p>Javascript中常见的异步编程模型</p>
<pre><code>回调函数

function loading(callback) {
    // 持续3秒的loading展示
    setTimeout(function () {
        callback();
    }, 3000);
}
function show() {
    // 展示真实数据给用户
}
loading(show);
// more code
</code></pre><p>代码中的loading(show)就是将函数show()作为函数loading()的参数。在loading()完成3秒的loading之后，再去执行回调函数（示例使用了setTimeout来模拟）。通过这种方法，show()就变成了异步调用，它的执行时机被推迟到loading()即将完成之前。意思就是发出一个调用后，show函数立刻被调用，结果并没有返回，但是立即返回了函数。</p>
<pre><code>事件监听
</code></pre><p>事件监听在UI编程中随处可见。比如我给一个按钮绑定一个点击事件，给一个输入框绑定一个键盘敲击事件等等。比如下面的代码，</p>
<pre><code>$(&apos;#button&apos;).on(&apos;click&apos;, function () {
    console.log(&apos;我被点了&apos;);
});
</code></pre><p>上面使用了JQuery的语法，给一个按钮绑定了一个事件。当事件触发时，会执行绑定的逻辑。这比较容易理解。</p>
<p>除了界面事件之外，通常我们还有各种网络请求事件，比如ajax，websocket等等。这些网络请求在不同阶段也会触发各种事件，如果程序中有绑定相关处理逻辑，那么当事件触发时就会去执行相关逻辑。</p>
<pre><code>ES6中的Promise
</code></pre><p>具体可以看阮一峰的详细教程<br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/promise</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>Ajax笔记</title>
    <link href="http://yoursite.com/2017/08/06/Ajax%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/06/Ajax笔记/</id>
    <published>2017-08-06T09:51:40.000Z</published>
    <updated>2017-08-11T13:07:22.108Z</updated>
    
    <content type="html"><![CDATA[<p>AJAX包括以下几个步骤。</p>
<pre><code>1.创建AJAX对象
2.发出HTTP请求
3.接收服务器传回的数据
4.更新网页数据
</code></pre><p>概括起来，就是一句话，AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。<br>AJAX可以是同步请求，也可以是异步请求。但是，大多数情况下，特指异步请求。因为同步的Ajax请求，对浏览器有“堵塞效应”。<br>意思就是在调用结果返回之前，当前线程会被挂起等待。直到得到结果之后函数调用才会返回。<br>而非阻塞则是在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<p>XMLHttpRequest对象用来在浏览器与服务器之间传送数据。</p>
<pre><code>var ajax = new XMLHttpRequest();
ajax.open(&apos;GET&apos;, &apos;http://www.example.com/page.php&apos;, true);
</code></pre><p>上面代码向指定的服务器网址，发出GET请求。</p>
<p>然后，AJAX指定回调函数，监听通信状态（readyState属性）的变化。</p>
<pre><code>ajax.onreadystatechange = handleStateChange;
</code></pre><p>一旦拿到服务器返回的数据，AJAX不会刷新整个网页，而是只更新相关部分，从而不打断用户正在做的事情。<br>注意，AJAX只能向同源网址（协议、域名、端口都相同）发出HTTP请求，如果发出跨源请求，就会报错</p>
<p>下面是XMLHttpRequest对象的典型用法。</p>
<p>var xhr = new XMLHttpRequest();</p>
<pre><code>// 指定通信过程中状态改变时的回调函数
xhr.onreadystatechange = function(){
  // 通信成功时，状态值为4
  if (xhr.readyState === 4){
    if (xhr.status === 200){
      console.log(xhr.responseText);
    } else {
      console.error(xhr.statusText);
    }
  }
};
xhr.onerror = function (e) {
  console.error(xhr.statusText);
};
// open方式用于指定HTTP动词、请求的网址、是否异步
xhr.open(&apos;GET&apos;, &apos;/endpoint&apos;, true);
// 发送HTTP请求
xhr.send(null);


XMLHttpRequest实例的属性
</code></pre><p>readyState是一个只读属性，用一个整数和对应的常量，表示XMLHttpRequest请求当前所处的状态。</p>
<p>0，对应常量UNSENT，表示XMLHttpRequest实例已经生成，但是open()方法还没有被调用。<br>1，对应常量OPENED，表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息。<br>2，对应常量HEADERS_RECEIVED，表示send()方法已经执行，并且头信息和状态码已经收到。<br>3，对应常量LOADING，表示正在接收服务器传来的body部分的数据，如果responseType属性是text或者空字符串，responseText就会包含已经收到的部分信息。<br>4，对应常量DONE，表示服务器数据已经完全接收，或者本次接收已经失败了。</p>
<p>onreadystatechange属性指向一个回调函数，当readystatechange事件发生的时候，这个回调函数就会调用，并且XMLHttpRequest实例的readyState属性也会发生变化。</p>
<p>另外，如果使用abort()方法，终止XMLHttpRequest请求，onreadystatechange回调函数也会被调用。</p>
<pre><code>var xmlhttp = new XMLHttpRequest();
xmlhttp.open( &apos;GET&apos;, &apos;http://example.com&apos; , true );
xmlhttp.onreadystatechange = function () {
  if ( XMLHttpRequest.DONE != xmlhttp.readyState ) {
    return;
  }
  if ( 200 != xmlhttp.status ) {
    return;
  }
  console.log( xmlhttp.responseText );
};
xmlhttp.send();
</code></pre><p>response属性为只读，返回接收到的数据体（即body部分）。它的类型可以是ArrayBuffer、Blob、Document、JSON对象、或者一个字符串，这由XMLHttpRequest.responseType属性的值决定。<br>如果本次请求没有成功或者数据不完整，该属性就会等于null。</p>
<p>responseType属性用来指定服务器返回数据（xhr.response）的类型。</p>
<p>“”：字符串（默认值）<br>“arraybuffer”：ArrayBuffer对象<br>“blob”：Blob对象<br>“document”：Document对象<br>“json”：JSON对象<br>“text”：字符串<br>text类型适合大多数情况，而且直接处理文本也比较方便，document类型适合返回XML文档的情况，blob类型适合读取二进制数据，比如图片文件。</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);
xhr.responseType = &apos;blob&apos;;
xhr.onload = function(e) {
  if (this.status == 200) {
    var blob = new Blob([this.response], {type: &apos;image/png&apos;});
    // 或者
    var blob = oReq.response;
  }
};
xhr.send();
</code></pre><p>如果将这个属性设为ArrayBuffer，就可以按照数组的方式处理二进制数据。</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);
xhr.responseType = &apos;arraybuffer&apos;;
xhr.onload = function(e) {
  var uInt8Array = new Uint8Array(this.response);
  for (var i = 0, len = binStr.length; i &lt; len; ++i) {
  // var byte = uInt8Array[i];
  }
};
xhr.send();
</code></pre><p>如果将这个属性设为“json”，支持JSON的浏览器（Firefox&gt;9，chrome&gt;30），就会自动对返回数据调用JSON.parse()方法。也就是说，你从xhr.response属性（注意，不是xhr.responseText属性）得到的不是文本，而是一个JSON对象。</p>
<p>XHR2支持Ajax的返回类型为文档，即xhr.responseType=”document” 。这意味着，对于那些打开CORS的网站，我们可以直接用Ajax抓取网页，然后不用解析HTML字符串，直接对XHR回应进行DOM操作。</p>
<p>responseText属性返回从服务器接收到的字符串，该属性为只读。如果本次请求没有成功或者数据不完整，该属性就会等于null。<br>如果服务器返回的数据格式是JSON，就可以使用responseText属性。</p>
<pre><code>var data = ajax.responseText;
data = JSON.parse(data);
</code></pre><p>responseType<br>responseType属性用来指定服务器返回数据（xhr.response）的类型。</p>
<p>”“：字符串（默认值）<br>“arraybuffer”：ArrayBuffer对象<br>“blob”：Blob对象<br>“document”：Document对象<br>“json”：JSON对象<br>“text”：字符串<br>text类型适合大多数情况，而且直接处理文本也比较方便，document类型适合返回XML文档的情况，blob类型适合读取二进制数据，比如图片文件。</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);
xhr.responseType = &apos;blob&apos;;
xhr.onload = function(e) {
  if (this.status == 200) {
    var blob = new Blob([this.response], {type: &apos;image/png&apos;});
    // 或者
    var blob = oReq.response;
  }
};
</code></pre><p>xhr.send();<br>如果将这个属性设为ArrayBuffer，就可以按照数组的方式处理二进制数据。</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);
xhr.responseType = &apos;arraybuffer&apos;;
xhr.onload = function(e) {
  var uInt8Array = new Uint8Array(this.response);
  for (var i = 0, len = binStr.length; i &lt; len; ++i) {
  // var byte = uInt8Array[i];
  }
};
</code></pre><p>xhr.send();<br>如果将这个属性设为“json”，支持JSON的浏览器（Firefox&gt;9，chrome&gt;30），就会自动对返回数据调用JSON.parse()方法。也就是说，你从xhr.response属性（注意，不是xhr.responseText属性）得到的不是文本，而是一个JSON对象。</p>
<p>XHR2支持Ajax的返回类型为文档，即xhr.responseType=”document” 。这意味着，对于那些打开CORS的网站，我们可以直接用Ajax抓取网页，然后不用解析HTML字符串，直接对XHR回应进行DOM操作。</p>
<p>responseText<br>responseText属性返回从服务器接收到的字符串，该属性为只读。如果本次请求没有成功或者数据不完整，该属性就会等于null。</p>
<p>如果服务器返回的数据格式是JSON，就可以使用responseText属性。</p>
<pre><code>var data = ajax.responseText;
data = JSON.parse(data);
</code></pre><p>responseXML属性返回从服务器接收到的Document对象，该属性为只读。如果本次请求没有成功，或者数据不完整，或者不能被解析为XML或HTML，该属性等于null。<br>返回的数据会被直接解析为DOM对象</p>
<p>status属性为只读属性，表示本次请求所得到的HTTP状态码，它是一个整数。一般来说，如果通信成功的话，这个状态码是200。</p>
<pre><code>200, OK，访问正常
301, Moved Permanently，永久移动
302, Move temporarily，暂时移动
304, Not Modified，未修改
307, Temporary Redirect，暂时重定向
401, Unauthorized，未授权
403, Forbidden，禁止访问
404, Not Found，未发现指定网址
500, Internal Server Error，服务器发生错误
</code></pre><p>基本上，只有2xx和304的状态码，表示服务器返回是正常状态。</p>
<p>statusText属性为只读属性，返回一个字符串，表示服务器发送的状态提示。不同于status属性，该属性包含整个状态信息，比如”200 OK“。</p>
<p>timeout属性等于一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。</p>
<pre><code>  var xhr = new XMLHttpRequest();
  xhr.ontimeout = function () {
    console.error(&quot;The request for &quot; + url + &quot; timed out.&quot;);
  };
  xhr.onload = function() {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        callback.apply(xhr, args);
      } else {
        console.error(xhr.statusText);
      }
    }
  };
  xhr.open(&quot;GET&quot;, url, true);
  xhr.timeout = timeout;
  xhr.send(null);
}
</code></pre><p>事件监听接口<br>XMLHttpRequest第一版，只能对onreadystatechange这一个事件指定回调函数。该事件对所有情况作出响应。 XMLHttpRequest第二版允许对更多的事件指定回调函数。</p>
<p>onloadstart 请求发出<br>onprogress 正在发送和加载数据<br>onabort 请求被中止，比如用户调用了abort()方法<br>onerror 请求失败<br>onload 请求成功完成<br>ontimeout 用户指定的时限到期，请求还未完成<br>onloadend 请求完成，不管成果或失败</p>
<pre><code>xhr.onload = function() {
 var responseText = xhr.responseText;
 console.log(responseText);
 // process the response.
};
xhr.onerror = function() {
  console.log(&apos;There was an error!&apos;);
};
</code></pre><p>注意，如果发生网络错误（比如服务器无法连通），onerror事件无法获取报错信息，所以只能显示报错。</p>
<p>withCredentials属性是一个布尔值，表示跨域请求时，用户信息（比如Cookie和认证的HTTP头信息）是否会包含在请求之中，默认为false。即向example.com发出跨域请求时，不会发送example.com设置在本机上的Cookie（如果有的话）。</p>
<p>如果你需要通过跨域AJAX发送Cookie，需要打开withCredentials。</p>
<p>xhr.withCredentials = true;<br>为了让这个属性生效，服务器必须显式返回Access-Control-Allow-Credentials这个头信息。</p>
<p>Access-Control-Allow-Credentials: true<br>.withCredentials属性打开的话，不仅会发送Cookie，还会设置远程主机指定的Cookie。注意，此时你的脚本还是遵守同源政策，无法 从document.cookie或者HTTP回应的头信息之中，读取这些Cookie。</p>
<pre><code>XMLHttpRequest实例的方法
</code></pre><p>abort()<br>abort方法用来终止已经发出的HTTP请求。</p>
<pre><code>ajax.open(&apos;GET&apos;, &apos;http://www.example.com/page.php&apos;, true);
var ajaxAbortTimer = setTimeout(function() {
  if (ajax) {
    ajax.abort();
    ajax = null;
  }
}, 5000);
</code></pre><p>上面代码在发出5秒之后，终止一个AJAX请求。</p>
<p>open()<br>XMLHttpRequest对象的open方法用于指定发送HTTP请求的参数，它的使用格式如下，一共可以接受五个参数。</p>
<pre><code>method：表示HTTP动词，比如“GET”、“POST”、“PUT”和“DELETE”。
url: 表示请求发送的网址。
async: 格式为布尔值，默认为true，表示请求是否为异步。如果设为false，则send()方法只有等到收到服务器返回的结果，才会有返回值。
user：表示用于认证的用户名，默认为空字符串。
password：表示用于认证的密码，默认为空字符串。
</code></pre><p>如果对使用过open()方法的请求，再次使用这个方法，等同于调用abort()。</p>
<p>下面发送POST请求的例子。</p>
<pre><code>xhr.open(&apos;POST&apos;, encodeURI(&apos;someURL&apos;));
xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);
xhr.onload = function() {};
xhr.send(encodeURI(&apos;dataString&apos;));
</code></pre><p>上面方法中，open方法向指定URL发出POST请求，send方法送出实际的数据。</p>
<p>下面是一个同步AJAX请求的例子。</p>
<pre><code>var request = new XMLHttpRequest();
request.open(&apos;GET&apos;, &apos;/bar/foo.txt&apos;, false);
request.send(null);
if (request.status === 200) {
  console.log(request.responseText);
}
send()
</code></pre><p>send方法用于实际发出HTTP请求。如果不带参数，就表示HTTP请求只包含头信息，也就是只有一个URL，典型例子就是GET请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是POST请求。</p>
<pre><code>ajax.open(&apos;GET&apos;
  , &apos;http://www.example.com/somepage.php?id=&apos; + encodeURIComponent(id)
  , true
);
</code></pre><p>// 等同于</p>
<pre><code>var data = &apos;id=&apos; + encodeURIComponent(id));
ajax.open(&apos;GET&apos;, &apos;http://www.example.com/somepage.php&apos;, true);
ajax.send(data);
</code></pre><p>上面代码中，GET请求的参数，可以作为查询字符串附加在URL后面，也可以作为send方法的参数。</p>
<p>下面是发送POST请求的例子。</p>
<pre><code>var data = &apos;email=&apos;
  + encodeURIComponent(email)
  + &apos;&amp;password=&apos;
  + encodeURIComponent(password);
ajax.open(&apos;POST&apos;, &apos;http://www.example.com/somepage.php&apos;, true);
ajax.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);
ajax.send(data);
</code></pre><p>如果请求是异步的（默认为异步），该方法在发出请求后会立即返回。如果请求为同步，该方法只有等到收到服务器回应后，才会返回。</p>
<p>注意，所有XMLHttpRequest的监听事件，都必须在send()方法调用之前设定。</p>
<p>send方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。</p>
<pre><code>void send();
void send(ArrayBufferView data);
void send(Blob data);
void send(Document data);
void send(String data);
void send(FormData data);
</code></pre><p>如果发送Document数据，在发送之前，数据会先被串行化。</p>
<p>发送二进制数据，最好使用ArrayBufferView或Blob对象，这使得通过Ajax上传文件成为可能。</p>
<p>下面是一个上传ArrayBuffer对象的例子。</p>
<pre><code>function sendArrayBuffer() {
  var xhr = new XMLHttpRequest();
  var uInt8Array = new Uint8Array([1, 2, 3]);
  xhr.open(&apos;POST&apos;, &apos;/server&apos;, true);
  xhr.onload = function(e) { ... };
  xhr.send(uInt8Array.buffer);
}
</code></pre><p>FormData类型可以用于构造表单数据。</p>
<pre><code>var formData = new FormData();
formData.append(&apos;username&apos;, &apos;张三&apos;);
formData.append(&apos;email&apos;, &apos;zhangsan@example.com&apos;);
formData.append(&apos;birthDate&apos;, 1940);
var xhr = new XMLHttpRequest();
xhr.open(&quot;POST&quot;, &quot;/register&quot;);
xhr.send(formData);
</code></pre><p>上面的代码构造了一个formData对象，然后使用send方法发送。它的效果与点击下面表单的submit按钮是一样的。</p>
<pre><code>&lt;form id=&apos;registration&apos; name=&apos;registration&apos; action=&apos;/register&apos;&gt;
    &lt;input type=&apos;text&apos; name=&apos;username&apos; value=&apos;张三&apos;&gt;
    &lt;input type=&apos;email&apos; name=&apos;email&apos; value=&apos;zhangsan@example.com&apos;&gt;
    &lt;input type=&apos;number&apos; name=&apos;birthDate&apos; value=&apos;1940&apos;&gt;
    &lt;input type=&apos;submit&apos; onclick=&apos;return sendForm(this.form);&apos;&gt;
&lt;/form&gt;
</code></pre><p>FormData也可以将现有表单构造生成。</p>
<pre><code>var formElement = document.querySelector(&quot;form&quot;);
var request = new XMLHttpRequest();
request.open(&quot;POST&quot;, &quot;submitform.php&quot;);
request.send(new FormData(formElement));
</code></pre><p>FormData对象还可以对现有表单添加数据，这为我们操作表单提供了极大的灵活性。</p>
<pre><code>function sendForm(form) {
    var formData = new FormData(form);
    formData.append(&apos;csrf&apos;, &apos;e69a18d7db1286040586e6da1950128c&apos;);
    var xhr = new XMLHttpRequest();
    xhr.open(&apos;POST&apos;, form.action, true);
    xhr.onload = function(e) {
        // ...
    };
    xhr.send(formData);
    return false;
}
var form = document.querySelector(&apos;#registration&apos;);
sendForm(form);
</code></pre><p>FormData对象也能用来模拟File控件，进行文件上传。</p>
<pre><code>function uploadFiles(url, files) {
  var formData = new FormData();
  for (var i = 0, file; file = files[i]; ++i) {
    formData.append(file.name, file); // 可加入第三个参数，表示文件名
  }
  var xhr = new XMLHttpRequest();
  xhr.open(&apos;POST&apos;, url, true);
  xhr.onload = function(e) { ... };
  xhr.send(formData);  // multipart/form-data
}
document.querySelector(&apos;input[type=&quot;file&quot;]&apos;).addEventListener(&apos;change&apos;, function(e) {
  uploadFiles(&apos;/server&apos;, this.files);
}, false);
</code></pre><p>FormData也可以加入JavaScript生成的文件。</p>
<p>// 添加JavaScript生成的文件</p>
<pre><code>var content = &apos;&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;&apos;;
var blob = new Blob([content], { type: &quot;text/xml&quot;});
formData.append(&quot;webmasterfile&quot;, blob);
setRequestHeader()
</code></pre><p>setRequestHeader方法用于设置HTTP头信息。该方法必须在open()之后、send()之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。</p>
<pre><code>xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;);
xhr.setRequestHeader(&apos;Content-Length&apos;, JSON.stringify(data).length);
xhr.send(JSON.stringify(data));
</code></pre><p>上面代码首先设置头信息Content-Type，表示发送JSON格式的数据；然后设置Content-Length，表示数据长度；最后发送JSON数据。</p>
<pre><code>Fetch API
</code></pre><p>Fetch API是一种新规范，用来取代XMLHttpRequest对象。它主要有两个特点，一是接口合理化，Ajax是将所有不同性质的接口都放在XHR对象上，而Fetch是将它们分散在几个不同的对象上，设计更合理；二是Fetch操作返回Promise对象，避免了嵌套的回调函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AJAX包括以下几个步骤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建AJAX对象
2.发出HTTP请求
3.接收服务器传回的数据
4.更新网页数据
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;概括起来，就是一句话，AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服
    
    </summary>
    
      <category term="Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue组件理解</title>
    <link href="http://yoursite.com/2017/08/02/Vue%E7%BB%84%E4%BB%B6%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/02/Vue组件理解/</id>
    <published>2017-08-02T12:47:50.000Z</published>
    <updated>2017-08-11T13:07:04.477Z</updated>
    
    <content type="html"><![CDATA[<p>props</p>
<p>组件实例的作用域是孤立的。这意味着不能在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的 props 选项。<br>子组件要显式地用 props 选项声明它期待获得的数据：</p>
<pre><code>Vue.component(&apos;child&apos;, {
  // 声明 props
  props: [&apos;message&apos;],
  // 就像 data 一样，prop 可以用在模板内
  // 同样也可以在 vm 实例中像“this.message”这样使用
  template: &apos;&lt;span&gt;{{ message }}&lt;/span&gt;&apos;
})
</code></pre><p>然后我们可以直接在子组件中传入字符串：</p>
<pre><code>&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;
</code></pre><p>结果：hello</p>
<p>在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件：</p>
<pre><code>&lt;div&gt;
  &lt;input v-model=&quot;parentMsg&quot;&gt;
  &lt;br&gt;
  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;
&lt;/div&gt;
</code></pre><p>修改 prop 中数据的两种原因：<br>prop 作为初始值传入后，子组件想把它当作局部数据来用；<br>prop 作为初始值传入，由子组件处理成其它数据输出。<br>对这两种原因，正确的应对方式是：<br>定义一个局部变量，并用 prop 的值初始化它：</p>
<pre><code>props: [&apos;initialCounter&apos;],
data: function () {
  return { counter: this.initialCounter }
}
</code></pre><p>定义一个计算属性，处理 prop 的值并返回。</p>
<pre><code>props: [&apos;size&apos;],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
</code></pre><p>注意：在JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p>
<p>子组件要把数据传递回去就是自定义事件<br>使用 v-on 绑定自定义事件</p>
<p>每个 Vue 实例都实现了事件接口 (Events interface)，即：<br>使用 $on(eventName) 监听事件<br>使用 $emit(eventName) 触发事件</p>
<p>父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。不能用 $on 侦听子组件抛出的事件，而必须在模板里直接用 v-on 绑定<br>v-on将increment事件与incrementTotal事件互相绑定了，increment事件触发时incrementTotal事件也触发，子组件已经和它外部完全解耦了。它所做的只是报告自己的内部事件，至于父组件是否关心则与它无关。<br>    <div id="counter-event-example"><br>      <p></p><br>      <button-counter v-on:increment="incrementTotal"></button-counter><br>      <button-counter v-on:increment="incrementTotal"></button-counter><br>    </div></p>
<pre><code>Vue.component(&apos;button-counter&apos;, {
  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;{{ counter }}&lt;/button&gt;&apos;,
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit(&apos;increment&apos;)
    }
  },
})
new Vue({
  el: &apos;#counter-event-example&apos;,
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</code></pre><p>总之v-on是监听绑定事件的，而v-bind是绑定属性参数的，vm-$on(事件，回调函数)是监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。<br>vm.$emit(事件，参数)是触发当前实例上的事件。附加参数都会传给监听器回调。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;props&lt;/p&gt;
&lt;p&gt;组件实例的作用域是孤立的。这意味着不能在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的 props 选项。&lt;br&gt;子组件要显式地用 props 选项声明它期待获得的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vue.
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Ajax跨域理解</title>
    <link href="http://yoursite.com/2017/07/29/Ajax%E8%B7%A8%E5%9F%9F%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/07/29/Ajax跨域理解/</id>
    <published>2017-07-29T05:02:01.000Z</published>
    <updated>2017-08-11T13:07:20.692Z</updated>
    
    <content type="html"><![CDATA[<p>什么是跨域？</p>
<p>首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表：</p>
<p>same-origin policy [同源策略]<br>　　在客户端编程语言中，如javascript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。</p>
<p>　　那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。比如<a href="http://www.example.org/和http://www.example.org/sub/是同域，而http://www.example.org" target="_blank" rel="external">http://www.example.org/和http://www.example.org/sub/是同域，而http://www.example.org</a>, <a href="https://www.example.org" target="_blank" rel="external">https://www.example.org</a>, <a href="http://www.example.org:8080" target="_blank" rel="external">http://www.example.org:8080</a>, <a href="http://sub.example.org中的任何两个都将构成跨域。" target="_blank" rel="external">http://sub.example.org中的任何两个都将构成跨域。</a></p>
<p>CORS</p>
<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>只要同时满足以下两大条件，就属于简单请求。<br>（1) 请求方法是以下三种方法之一：<br>HEAD<br>GET<br>POST<br>（2）HTTP的头信息不超出以下几种字段：<br>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain<br>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p>
<p>以下是对两种不同请求详解：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是跨域？&lt;/p&gt;
&lt;p&gt;首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表：&lt;/p&gt;
&lt;p&gt;same-origin policy [同源策略]&lt;br&gt;　　
    
    </summary>
    
      <category term="Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6 (一)</title>
    <link href="http://yoursite.com/2017/07/25/ES6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/07/25/ES6总结/</id>
    <published>2017-07-25T08:38:10.000Z</published>
    <updated>2017-08-11T13:07:16.645Z</updated>
    
    <content type="html"><![CDATA[<p>目录</p>
<p>1.var 和 let/const 的比较用<br>2.块级作用域代替 IIFES<br>3.箭头函数<br>4.字符串<br>5.解构<br>6.模块</p>
<pre><code>var 和 let/const 的比较
</code></pre><p>除了 var ，我们现在还可以使用两个新的标示符来定义一个变量 —— let 和 const。和 var 不一样的是，let 和 const 不存在变量提升。<br>使用 var 的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var snack = &apos;Meow Mix&apos;;</div><div class="line">function getFood(food) &#123;</div><div class="line">    if (food) &#123;</div><div class="line">        var snack = &apos;Friskies&apos;;</div><div class="line">        return snack;</div><div class="line">    &#125;</div><div class="line">    return snack;</div><div class="line">&#125;</div><div class="line">getFood(false); // undefined</div><div class="line">alert(&apos;Hello World!&apos;);</div><div class="line"></div></pre></td></tr></table></figure>
<p>当我们用 let 代替 var 的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let snack = &apos;Meow Mix&apos;;</div><div class="line">function getFood(food) &#123;</div><div class="line">    if (food) &#123;</div><div class="line">        let snack = &apos;Friskies&apos;;</div><div class="line">        return snack;</div><div class="line">    &#125;</div><div class="line">    return snack;</div><div class="line">&#125;</div><div class="line">getFood(false); // &apos;Meow Mix&apos;</div></pre></td></tr></table></figure><br>当我们重构使用 var 的老代码的时候应该注意上面的变化。盲目地使用 let 替换 var 可能会出现出乎意料的情况。</p>
<p>注意：let 和 const 是块级作用域，因此在变量未被定义之前使用它会产生一个 ReferenceError。<br>    console.log(x); // ReferenceError: x is not defined<br>    let x = ‘hi’;</p>
<p>在遗留代码中放弃使用 var 声明意味着需要很小心地重构；在新的项目代码中，使用 let 声明一个可以改变的变量，用 const 声明一个不能被重新赋值的变量。<br>用块级作用域代替 IIFES</p>
<p>函数立即执行表达式 的通常用途是创造一个内部的作用域，在 ES6 中，我们能够创造一个块级作用域而不仅限于函数作用域：<br>    IIFES：</p>
<pre><code>(function () {
    var food = &apos;Meow Mix&apos;;
}());
console.log(food); // Reference Error
</code></pre><p>使用 ES6 的块级作用域：</p>
<p>{<br>    let food = ‘Meow Mix’;<br>}<br>console.log(food); // Reference Error</p>
<pre><code>箭头函数
</code></pre><p>我们经常需要给回调函数维护一个词法作用域的上下文 this。<br>看看这个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = function (arr) &#123;</div><div class="line">    return arr.map(function (character) &#123;</div><div class="line">        return this.name + character; // Cannot read property &apos;name&apos; of undefined</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>一个常用的解决办法是把 this 存在一个变量中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = function (arr) &#123;</div><div class="line">    var that = this; // Store the context of this</div><div class="line">    return arr.map(function (character) &#123;</div><div class="line">        return that.name + character;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>我们也可以传递一个合适的 this 上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = function (arr) &#123;</div><div class="line">    return arr.map(function (character) &#123;</div><div class="line">        return this.name + character;</div><div class="line">    &#125;, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>我们还可以绑定上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = function (arr) &#123;</div><div class="line">    return arr.map(function (character) &#123;</div><div class="line">        return this.name + character;</div><div class="line">    &#125;.bind(this));</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>使用箭头函数，this 将不会受到影响，并且我们可以重写上面的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = function (arr) &#123;</div><div class="line">    return arr.map(character =&gt; this.name + character);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>当你需要维护一个 this 上下文的时候使用 箭头函数。<br>在我们写一个函数的时候，箭头函数更加简洁并且可以很简单地返回一个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var squares = arr.map(function (x) &#123; return x * x &#125;); // Function Expression</div><div class="line">const arr = [1, 2, 3, 4, 5];</div><div class="line">const squares = arr.map(x =&gt; x * x); // Arrow Function for terser implementation</div></pre></td></tr></table></figure></p>
<p>字符串</p>
<p>在 ES6 中，标准库升级了很多，在这些变化中有许多新的对于字符串的函数，比如 .includes() 和 .repeat()。</p>
<p>.includes( )</p>
<p>var string = ‘food’;<br>var substring = ‘foo’;<br>console.log(string.indexOf(substring) &gt; -1);<br>之前我们使用 indexOf() 函数的返回值是否 &gt;-1 来判断字符串是否包含某些字符串，现在我们更简单地使用 .includes() 来返回一个布尔值来判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const string = &apos;food&apos;;</div><div class="line">const substring = &apos;foo&apos;;</div><div class="line">console.log(string.includes(substring)); // true</div><div class="line">.repeat( )</div><div class="line"></div><div class="line">function repeat(string, count) &#123;</div><div class="line">    var strings = [];</div><div class="line">    while(strings.length &lt; count) &#123;</div><div class="line">        strings.push(string);</div><div class="line">    &#125;</div><div class="line">    return strings.join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在 ES6 中，可以更简便地实现：</p>
<p>// String.repeat(numberOfRepetitions)<br>‘meow’.repeat(3); // ‘meowmeowmeow’<br>                                模版字符串</p>
<p>使用 模版字符串 我们就可以不用对某些特殊自负进行转义处理了：</p>
<p>var text = “This string contains \”double quotes\” which are escaped.”;<br>let text = ‘This string contains “double quotes” which don’t need to be escaped anymore.’;<br>模版字符串 还支持插入，可以把变量值和字符串连接起来.</p>
<p>var name = ‘Tiger’;<br>var age = 13;<br>console.log(‘My cat is named ‘ + name + ‘ and is ‘ + age + ‘ years old.’);<br>更简单：</p>
<p>const name = ‘Tiger’;<br>const age = 13;<br>console.log(‘My cat is named ${name} and is ${age} years old.’);<br>在 ES5 中，需要换行时，需要这样：</p>
<p>var text = (<br>    ‘cat\n’ +<br>    ‘dog\n’ +<br>    ‘nickelodeon’<br>);<br>或者这样：</p>
<p>var text = [<br>    ‘cat’,<br>    ‘dog’,<br>    ‘nickelodeon’<br>].join(‘\n’);<br>模版字符串 可以支持换行并且不需要额外的处理：</p>
<p>let text = (“cat<br>dog<br>nickelodeon”<br>);<br>模版字符串 还支持表达式：</p>
<p>let today = new Date();<br>let text = “The time and date is ${today.toLocaleString()}”;<br>                                      解构</p>
<p>结构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。</p>
<p>结构数组</p>
<p>var arr = [1, 2, 3, 4];<br>var a = arr[0];<br>var b = arr[1];<br>var c = arr[2];<br>var d = arr[3];<br>let [a, b, c, d] = [1, 2, 3, 4];<br>console.log(a); // 1<br>console.log(b); // 2</p>
<p>结构对象<br>var luke = { occupation: ‘jedi’, father: ‘anakin’ };<br>var occupation = luke.occupation; // ‘jedi’<br>var father = luke.father; // ‘anakin’<br>let luke = { occupation: ‘jedi’, father: ‘anakin’ };<br>let {occupation, father} = luke;<br>console.log(occupation); // ‘jedi’<br>console.log(father); // ‘anakin’</p>
<pre><code>模块
</code></pre><p>在 ES6 之前，我们使用 Browserify 这样的库来创建客户端的模块化，在 node.js 中使用 require。<br>在 ES6 中，我们可以直接使用所有类型的模块化（AMD 和 CommonJS）。</p>
<p>使用 CommonJS 的出口</p>
<p>module.exports = 1;<br>module.exports = { foo: ‘bar’ };<br>module.exports = [‘foo’, ‘bar’];<br>module.exports = function bar () {};</p>
<p>使用 ES6 的出口<br>在 ES6 中我们可以暴露多个值，使用 Exports：</p>
<p>export let name = ‘David’;<br>export let age  = 25;​​</p>
<p>或者暴露一个对象列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function sumTwo(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;</div><div class="line">function sumThree(a, b, c) &#123;</div><div class="line">    return a + b + c;</div><div class="line">&#125;</div><div class="line">export &#123; sumTwo, sumThree &#125;;</div></pre></td></tr></table></figure><br>我们还可以暴露函数、对象和其他的值，通过简单地使用 export 这个关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export function sumTwo(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;</div><div class="line">export function sumThree(a, b, c) &#123;</div><div class="line">    return a + b + c;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>最后，我们还可以绑定一个默认的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function sumTwo(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;</div><div class="line">function sumThree(a, b, c) &#123;</div><div class="line">    return a + b + c;</div><div class="line">&#125;</div><div class="line">let api = &#123;</div><div class="line">    sumTwo,</div><div class="line">    sumThree</div><div class="line">&#125;;</div><div class="line">export default api;</div><div class="line">/* Which is the same as</div><div class="line"> * export &#123; api as default &#125;;</div><div class="line"> */</div></pre></td></tr></table></figure><br>总是在模块的最后面使用 export default 方法，这可以让暴露的东西更加清晰并且可以节省时间去找出暴露出来值的名字。尤其如此，在 CommonJS 中通常的实践就是暴露一个简单的值或者对象。坚持这种模式，可以让我们的代码更加可读，并且在 ES6 和 CommonJS 模块之间更好地兼容。</p>
<p>ES6 中的导入<br>在 ES6 中同样提供了多样的导入方式，我们可以这么导入一个整个文件：</p>
<p>import ‘underscore’;<br>需要着重注意的一点是简单的导入整个文件会在那个文件的顶部执行所有的代码<br>和 Python 中类似，我们可以命名导入的值：</p>
<p>import { sumTwo, sumThree } from ‘math/addition’;<br>我们还可以重命名导入：</p>
<p>import {<br>    sumTwo as addTwoNumbers,<br>    sumThree as sumThreeNumbers<br>} from ‘math/addition’;<br>另外，我们可以导入所有的东西（整体加载）：</p>
<p>import * as util from ‘math/addition’;<br>最后，我们可以从一个模块中导入一个值的列表：</p>
<p>import * as additionUtil from ‘math/addition’;<br>const { sumTwo, sumThree } = additionUtil;<br>可以像这样导入默认绑定的输出：</p>
<p>import api from ‘math/addition’;<br>// Same as: import { default as api } from ‘math/addition’;<br>虽然最好保持出口的简单，但如果需要的话我们有时可以混合默认的进口和混合进口。当我们这样出口的时候：</p>
<p>// foos.js<br>export { foo as default, foo1, foo2 };<br>我们可以这样导入它们：</p>
<p>import foo, { foo1, foo2 } from ‘foos’;<br>当我们用 commonjs 的语法导入一个模块的出口时（比如 React），我们可以这样做：</p>
<p>import React from ‘react’;<br>const { Component, PropTypes } = React;<br>还有更精简的写法：</p>
<p>import React, { Component, PropTypes } from ‘react’;<br>导出的值是动态引用的，而不是拷贝。因此，在一个模块中改变一个变量的绑定将影响输出模块中的值。应该避免改变这些导出值的公共接口。</p>
<p>更多关于ES6模块<br><a href="http://es6.ruanyifeng.com/?search=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&amp;x=11&amp;y=2#docs/module" target="_blank" rel="external">http://es6.ruanyifeng.com/?search=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&amp;x=11&amp;y=2#docs/module</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;1.var 和 let/const 的比较用&lt;br&gt;2.块级作用域代替 IIFES&lt;br&gt;3.箭头函数&lt;br&gt;4.字符串&lt;br&gt;5.解构&lt;br&gt;6.模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var 和 let/const 的比较
&lt;/code&gt;&lt;/pre&gt;&lt;p
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
</feed>
